/*
 * This file is part of Nucleus, licensed under the MIT License (MIT). See the LICENSE.txt file
 * at the root of this project for more details.
 */
package io.github.nucleuspowered.nucleus.modules.invulnerability.services;

import com.google.inject.Inject;
import io.github.nucleuspowered.nucleus.api.module.invulnerability.NucleusInvulnerabilityService;
import io.github.nucleuspowered.nucleus.modules.invulnerability.InvulnerabilityKeys;
import io.github.nucleuspowered.nucleus.scaffold.service.ServiceBase;
import io.github.nucleuspowered.nucleus.scaffold.service.annotations.APIService;
import io.github.nucleuspowered.nucleus.services.INucleusServiceCollection;
import org.spongepowered.api.Sponge;
import org.spongepowered.api.entity.living.player.Player;
import org.spongepowered.api.entity.living.player.server.ServerPlayer;
import org.spongepowered.api.service.context.Context;
import org.spongepowered.api.service.context.ContextCalculator;
import org.spongepowered.api.service.permission.Subject;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.UUID;

@APIService(NucleusInvulnerabilityService.class)
public class InvulnerabilityService implements NucleusInvulnerabilityService, ContextCalculator<Subject>, ServiceBase {

    private final Map<UUID, Boolean> invulnerabilityCache = new HashMap<>();
    private final Context context = new Context(NucleusInvulnerabilityService.INVULNERABLE_CONTEXT, "true");
    private final INucleusServiceCollection serviceCollection;

    @Inject
    public InvulnerabilityService(final INucleusServiceCollection serviceCollection) {
        this.serviceCollection = serviceCollection;
    }

    @Override
    public void accumulateContexts(final Subject calculable, final Set<Context> accumulator) {
        if (calculable instanceof ServerPlayer && this.isInvulnerable(((ServerPlayer) calculable).getUniqueId())) {
            accumulator.add(this.context);
        }
    }

    @Override
    public boolean matches(final Context context, final Subject calculable) {
        return this.context.equals(context) && calculable instanceof ServerPlayer && this.isInvulnerable(((Player) calculable).getUniqueId());
    }

    @Override
    public boolean isInvulnerable(final UUID user) {
        return this.invulnerabilityCache.computeIfAbsent(
                user,
                uuid -> this.serviceCollection.storageManager()
                        .getUserService()
                        .getOnThread(user)
                        .flatMap(x -> x.get(InvulnerabilityKeys.INVLUNERABLE))
                        .orElse(false)
        );
    }

    @Override
    public void setInvulnerable(final UUID user, final boolean invulnerable) {
        this.serviceCollection.storageManager()
                .getUserService()
                .getOrNew(user)
                .thenAccept(x -> x.set(InvulnerabilityKeys.INVLUNERABLE, invulnerable));

        Sponge.getServer().getPlayer(user).ifPresent(x -> this.invulnerabilityCache.put(user, invulnerable));
    }

    public boolean cacheEmpty() {
        return this.invulnerabilityCache.isEmpty();
    }

    public void removeFromCache(final UUID uuid) {
        this.invulnerabilityCache.remove(uuid);
    }
}
