/*
 * This file is part of Nucleus, licensed under the MIT License (MIT). See the LICENSE.txt file
 * at the root of this project for more details.
 */
package io.github.nucleuspowered.nucleus.modules.invulnerability.listeners;

import com.google.inject.Inject;
import io.github.nucleuspowered.nucleus.modules.invulnerability.services.InvulnerabilityService;
import io.github.nucleuspowered.nucleus.core.scaffold.listener.ListenerBase;
import io.github.nucleuspowered.nucleus.core.services.INucleusServiceCollection;
import org.spongepowered.api.data.Keys;
import org.spongepowered.api.entity.Entity;
import org.spongepowered.api.entity.living.Agent;
import org.spongepowered.api.entity.living.player.server.ServerPlayer;
import org.spongepowered.api.event.Listener;
import org.spongepowered.api.event.cause.entity.damage.source.EntityDamageSource;
import org.spongepowered.api.event.entity.DamageEntityEvent;
import org.spongepowered.api.event.entity.ai.SetAITargetEvent;
import org.spongepowered.api.event.filter.Getter;
import org.spongepowered.api.event.network.ServerSideConnectionEvent;
import org.spongepowered.api.util.Ticks;

public class InvulnerabilityListener implements ListenerBase {

    private final InvulnerabilityService service;

    @Inject
    public InvulnerabilityListener(final INucleusServiceCollection serviceCollection) {
        this.service = serviceCollection.getServiceUnchecked(InvulnerabilityService.class);
    }

    @Listener
    public void onSetAITargetEvent(final SetAITargetEvent event, @Getter("target") final Entity entity) {
        if (entity instanceof ServerPlayer && this.service.isInvulnerable(entity.uniqueId())) {
            event.setCancelled(true); // cancel the change
        }
    }

    @Listener
    public void onPlayerStruck(final DamageEntityEvent event, @Getter("entity") final ServerPlayer pl) {
        if (this.service.isInvulnerable(pl.uniqueId())) {
            pl.offer(Keys.FIRE_TICKS, Ticks.zero());
            event.setBaseDamage(0);
            event.setCancelled(true);

            event.cause().allOf(EntityDamageSource.class).forEach(x -> {
                final Entity entity = x.source();
                if (entity instanceof Agent) {
                    this.disableAI((Agent) entity, pl);
                }
            });

            event.cause().allOf(Agent.class).forEach(f -> this.disableAI(f, pl));
        }
    }

    private void disableAI(final Agent agent, final ServerPlayer pl) {
        if (agent.get(Keys.TARGET_ENTITY).filter(y -> y.equals(pl)).isPresent()) {
            agent.remove(Keys.TARGET_ENTITY);
        }
    }

    @Listener
    public void onPlayerQuit(final ServerSideConnectionEvent.Disconnect event, @Getter("player") final ServerPlayer serverPlayer) {
        this.service.removeFromCache(serverPlayer.uniqueId());
    }
}
