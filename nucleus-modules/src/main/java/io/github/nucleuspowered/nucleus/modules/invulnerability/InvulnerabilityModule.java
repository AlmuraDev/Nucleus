/*
 * This file is part of Nucleus, licensed under the MIT License (MIT). See the LICENSE.txt file
 * at the root of this project for more details.
 */
package io.github.nucleuspowered.nucleus.modules.invulnerability;

import com.google.inject.Inject;
import io.github.nucleuspowered.nucleus.core.module.IModule;
import io.github.nucleuspowered.nucleus.modules.invulnerability.commands.InvulnerabilityCommand;
import io.github.nucleuspowered.nucleus.modules.invulnerability.config.InvulnerabilityConfig;
import io.github.nucleuspowered.nucleus.modules.invulnerability.infoprovider.InvulnerabilityInfoProvider;
import io.github.nucleuspowered.nucleus.modules.invulnerability.listeners.InvulnReloadableListener;
import io.github.nucleuspowered.nucleus.modules.invulnerability.listeners.InvulnerabilityListener;
import io.github.nucleuspowered.nucleus.modules.invulnerability.listeners.InvulnerabilityPvpListener;
import io.github.nucleuspowered.nucleus.modules.invulnerability.services.InvulnerabilityService;
import io.github.nucleuspowered.nucleus.core.scaffold.command.ICommandExecutor;
import io.github.nucleuspowered.nucleus.core.scaffold.listener.ListenerBase;
import io.github.nucleuspowered.nucleus.core.services.INucleusServiceCollection;
import io.github.nucleuspowered.nucleus.core.services.impl.playerinformation.NucleusProvider;
import org.spongepowered.api.Server;
import org.spongepowered.api.data.Keys;
import org.spongepowered.api.entity.living.player.server.ServerPlayer;
import org.spongepowered.api.event.Listener;
import org.spongepowered.api.event.lifecycle.LoadedGameEvent;
import org.spongepowered.api.event.lifecycle.StartedEngineEvent;
import org.spongepowered.api.event.lifecycle.StartingEngineEvent;

import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Optional;

public final class InvulnerabilityModule implements IModule.Configurable<InvulnerabilityConfig> {

    public static final String ID = "invulnerability";
    private final INucleusServiceCollection serviceCollection;

    @Inject
    public InvulnerabilityModule(final INucleusServiceCollection serviceCollection) {
        this.serviceCollection = serviceCollection;
    }

    @Override public void init(final INucleusServiceCollection serviceCollection) {
        final InvulnerabilityService service = new InvulnerabilityService(serviceCollection);
        serviceCollection.registerService(InvulnerabilityService.class, service, false);
    }

    @Override public Collection<Class<? extends ICommandExecutor>> getCommands() {
        return Collections.singletonList(InvulnerabilityCommand.class);
    }

    @Override public Optional<Class<?>> getPermissions() {
        return Optional.of(InvulnerabilityPermissions.class);
    }

    @Override public Collection<Class<? extends ListenerBase>> getListeners() {
        return Arrays.asList(
                InvulnerabilityListener.class,
                InvulnerabilityPvpListener.class,
                InvulnReloadableListener.class
        );
    }

    @Override public Class<InvulnerabilityConfig> getConfigClass() {
        return InvulnerabilityConfig.class;
    }

    @Override public InvulnerabilityConfig createInstance() {
        return new InvulnerabilityConfig();
    }

    @Override public Optional<NucleusProvider> getInfoProvider() {
        return Optional.of(new InvulnerabilityInfoProvider());
    }

    @Listener
    public void onStartingServer(final StartedEngineEvent<Server> lifecycleEvent) {
        final InvulnerabilityService invulnerabilityService = this.serviceCollection.getServiceUnchecked(InvulnerabilityService.class);
        Keys.FOOD_LEVEL.get().registerEvent(this.serviceCollection.pluginContainer(), ServerPlayer.class, event -> {
            if (event.getTargetHolder() instanceof ServerPlayer &&
                    invulnerabilityService.isInvulnerable(((ServerPlayer) event.getTargetHolder()).getUniqueId())) {
                event.setCancelled(true); // this is a food change event
            }
        });
    }

}
